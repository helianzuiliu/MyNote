---
tags:
  - 算法
aliases:
  - Banker
---

# 一、算法介绍

常用于多线程算法中避免出现死锁的方法之一

# 二、实现思路

将系统资源比作银行家的钱

银行家的钱放出去比作资源的分配

当银行家认为该线程在分配资源后的一定时间内无法将资源释放，则不会将资源分配给线程

分配资源的原则：

- 当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳进进程
- 进程可以分期请求资源，但请求的总数不能超过最大需求量
- 当系统现有的资源不能满足进程尚需的资源数时，对进程的请求可以推迟分配，但总能使进程在优先的时间里得到资源

银行家算法的主要组成部分包括以下内容：

1. **可用资源向量（Available）：** 表示当前系统中每种资源的可用数量。初始时，这些资源数量等于系统总资源数量。
2. **最大需求矩阵（Max）：** 每个进程对每种资源的最大需求量。它指示了每个进程可能需要的资源数目。
3. **已分配矩阵（Allocation）：** 每个进程已经分配到的资源数目。它表示了当前哪些资源被分配给了进程。
4. **需求矩阵（Need）：** 表示每个进程还需要的资源数目。它由最大需求矩阵减去已分配矩阵得到，表示了进程还需要多少资源才能完成。

银行家算法的运行过程如下

1. 当一个进程请求资源时，首先检查该请求是否小于等于它的需求（Need）以及是否小于等于系统中的可用资源（Available）。如果条件满足，就分配资源；否则，进程必须等待。
2. 如果资源分配后，系统仍然处于安全状态，即存在一种资源分配序列可以确保所有进程都能顺利执行而不陷入死锁，那么允许分配资源。
3. 如果资源分配后，系统不再处于安全状态，那么拒绝分配资源，以避免死锁的发生。

# 三、复杂度分析

# 四、实现代码

```c++
void Func(){

}

```

