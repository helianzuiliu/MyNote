# `std::bind`



























# `std::function`

`std::function`是一种通用的、多态的函数封装。它的原始形态是原生C中的函数指针

`std::function`的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，这些目标实体包括：
- 普通函数
- 函数指针
- `lambda`表达式
- `std::bind`对象
- 函数对象

> 其中，`lambda`表达式和`bind`对象也是C++11标准中提出的。

##### 普通函数

示例：

```cpp
int func(int a)
{
    return a;
}
```

> 当然，这里的普通函数可以是在类中定义的成员函数或者静态成员函数。

##### 函数指针

示例：

```cpp
typedef int (*pfunc)(int);
//可将func赋值给该函数指针
pfunc p = func;
```

##### `Lambda`表达式

`lambda`是一段随写随用的代码，不会被不安全的访问。

示例:

```cpp
auto func = [](int a){
    return a;
};
```

##### `bind`对象

示例

```cpp
#include <iostream>
#include <functional>
using namespace std;

void func(int x, int y)
{
    cout << "in func1: ";
    cout << "x = " << x << ", y = " << y << endl;
}

int main(int argc, char *argv[])
{

    std::function<void(int, int)> fc = std::bind(func, std::placeholders::_1, std::placeholders::_2);
    fc(1, 2); //

    return 0;
}
```

##### 函数对象

重载了函数调用运算符()的类的对象，即为函数对象，也可以叫做仿函数。

示例：

```cpp
class Functor
{
public:
    int operator()(int a)
    {
        return a;
    }
};
```

##### `std::function`

从上面的情况也可以看到，可调用对象的定义方式较多，而函数调用的方式较为类似，因此需要一个统一的方式保存这些对象。`std::function`也就因此诞生。

示例：

```cpp
#include <functional>
#include <iostream>
using namespace std;

typedef std::function<int(int)> callback;

// 普通函数
int func1(int a)
{
    return a;
}

// Lambda表达式
auto func2 = [](int a)
{
    return a;
};

// 函数对象
class Functor
{
public:
    int operator()(int a)
    {
        return a;
    }
};

int main()
{
    // 普通函数
    callback cb1 = func1;
    int result = cb1(10);
    cout << "cb1->output:" << result << endl;

    // Lambda表达式
    callback cb2 = func2;
    result = cb2(20);
    cout << "cb2->output:" << result << endl;

    // 函数对象
    Functor testFunctor;
    callback cb3 = testFunctor;
    result = cb3(30);
    cout << "cb3->output:" << result << endl;

    return 0;
}
```

##### 总结

关于可调用实体转换为`std::function`对象需要遵守以下两条原则：

- 转换后的`std::function`对象的参数能转换为可调用实体的参数；
- 可调用实体的返回值能转换为`std::function`对象的返回值。



