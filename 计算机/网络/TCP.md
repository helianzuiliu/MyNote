---
tags:
  - TCP/IP
---

tcp和udp都是传输层协议

**传输层：** 传输层是[[TCP_IP协议]]协议五层模型中的第四层。它提供了`应用程序`间的通信，它负责数据能够从发送端传输到接收端。其功能包括：**一、格式化信息流；二、提供可靠传输**。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。

# TCP

TCP全称`传输控制`协议，必须对数据的传输进行控制。

![[Pasted image 20240729164157.png]]

- 源端口号/目的端口号：表示数据从哪个`进程`来，要到那个进程去
- 32位序号：序号是`可靠传输`的关键因素。TCP将要传输的每个字节都进行了`编号`，序号是本报文段发送的数据组的`第一个`字节的编号，序号可以保证传输信息的有效性。**比如：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为401。**
- 32位确认序号：每一个`ACK`对应这一个确认号，它指明下一个期待收到的`字节`序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当`ACK`标志为1时才有效。**比如建立连接时，SYN报文的ACK标志位为0。**
- 4位首部长度(数据偏移)： 表示该TCP头部有多少个`32位bit`(有多少个4字节)，所以TCP头部大长度是`15 * 4 = 60`。根据该部分可以将TCP报头和有效载荷分离。TCP报文默认大小为20个字节。
- 6位标志位：
    **URG:它为了标志紧急指针是否有效。**  
    **ACK：标识确认号是否有效。**  
    **PSH:提示接收端应用程序立即将接收缓冲区的数据拿走。**  
    **RST：它是为了处理异常连接的， 告诉连接不一致的一方，我们的连接还没有建立好， 要求对方重新建立连接。我们把携带RST标识的称为复位报文段。**  
    **SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段。**  
    **FIN:通知对方, 本端要关闭连接了, 我们称携带FIN标识的为结束报文段。**
- 16位的`紧急`指针：按序到达是`TCP协议`保证可靠性的一种机制，但是也存在一些报文想优先被处理，这时就可以设置`紧急指针`，指向该报文即可，同时将紧急指针有效位置位`1`。
- 16位窗口大小：如果发送方发送`大量数据`，接收方接收不过来，会导致大量数据丢失。然后接收方可以发送给发送发消息让发送方发慢一点，这是`流量控制`。接收方将自己`接收缓冲器`剩余空间的大小告诉发送方叫做`16位窗口大小`。发送发可以根据窗口大小来`适配`发送的速度和大小，窗口大小最大是2的16次方，及64KB，但也可以根据选项中的某些位置扩展，最大扩展1G。
- 16位校验和：发送端填充，`CRC`校验。如果接收端校验不通过， 则认为数据有问题(此处的检验和不光包含`TCP首部`也包含`TCP数据部分`)。

## 确认应答机制

![[Pasted image 20240729172104.png]]

接收端收到一条报文后，向发送端发送一条`确认ACK`，此ACK的作用就是告诉发送端：接收端已经成功的收到了消息，并且希望收到下一条报文的`序列号`是什么。这个确认号就是期望的`下一个报文`的序号。

每一个ACK都带有对应的`确认序列号`，意思是告诉**发送者，我们已经收到了哪些数据，下一个发送数据应该从哪里开始**。 如上图，主机A给主机B发送了1-1000的数据，ACK应答，携带了1001序列号。告诉主机A，我已经接受到了1-1000数据，下一次你从1001开始发送数据。

## **超时重传:**

![[Pasted image 20240729172515.png]]

TCP在`传输数据`过程中，还加入了`超时重传`机制。假设主机A发送数据给主机B，主机B没有收到数据包，主机B自然就不会应答，如果主机A在一个特定时间间隔内没有收到主机B发来的确认应答，就会进行重发，这就是`超时重传机制`。  
当然还存在另一种可能就是`主机A`未收到`B`发来的确认应答，也可能是因为`ACK`丢失了。

![[Pasted image 20240729172558.png]]

因此主机B会收到很多`重复`数据，那么TCP协议需要能够识别出那些包是`重复的包`， 并且把重复的包丢弃掉，这时候我们可以利用前面提到的`16位序列号`， 就可以很容易做到`去重`的效果。

### **超时重发的时间应该如何确定？**

在理想的情况下，可以找到一个`小的时间`来保证 "确认应答"一定能在这个时间内返回。但是这个时间的长短，随着`网络环境`的不同是有差异的。如果超时时间设的太长，会影响整体的`重传`效率。如果超时时间设的太短，有可能会`频繁发送重复`的包。`TCP`为了保证无论在任何环境下都能比较`高性能`的通信，因此会`动态计算`这个最大超时时间。

Linux中超时时间以`500ms`为一个单位进行控制，每次判定超时重发的`超时时间`都是`500ms`的整数倍。如果重发一次之后，仍然得不到应答，等待`2*500ms`后再进行重传。如果仍然得不到应答，等待`4*500ms`进行重传。依次类推，以`指数形式`递增，当累计到一定的重传次数，`TCP`认为网络或者对端主机出现`异常`，强制关闭连接。

## 连接管理机制

### 三次握手

在正常情况下, TCP要经过`三次握手`建立连接，`四次挥手`断开连接

**第一步** 有客户端想服务端发送一个tcp报文，这个报文不包含数据，且它的`SYN`字段被置为1,表示这是一个建立连接的请求,这个报文段也被称为SYN报文段,客户端的`TCP`程序随机选择一个序号作为客户端报文的初始序号（假设序号为`client_isn`），放入这个报文段的序号部分。这个报文段由运输层传递到网络层后，被封装在一个`IP`数据报中发往服务器；

**第二步** 第一步的SYN报文被服务器接收,并想客户端发送允许连接的报文,这条报文依然不包含数据,其`SYN`和`ACK`都被置为1,表示这是`SYN`报文的确认报文,这条报文被称为SYNACK报文，服务器随机选择一个序号，作为服务器报文段的初始序号（假设称为`server_isn`），并将其放入`SYNACK`报文段的序号部分，同时确认号字段被设置为`client_isn + 1`（`SYN`报文段的序号+1）。这个报文段可以解释为服务器向客户端说：“我收到了你的连接请求，我允许你连接，我的初始序号是`server_isn`”。

> 这里的`client_isn`和`server_isn`是用来分辨这个报文在这个连接中的顺序，比如客户端的第一条报文传输的序号是`client_isn`,则下一个传输的报文序号是`client_isn+1`,可以分辨这次传输的数据是整个传输的哪个位置

**第三步** 当客户端接受到来自服务器的`SYNACK`报文之后，客户端将为TCP连接分配资源（缓存和变量），同时生成`SYNACK`一条报文,并发送给服务器,这次的报文由于已经算是确立连接所以SYN标志将被置为0,表示这次连接不是请求连接的报文,ACK则置为1.同时这条报文的报文段被设置为`client_isn+1`,和前两个报文不同,第三次的报文是可以传输数据的,比如http请求就是在TCP的第三次握手报文发送到服务器的

至此,服务器和客户端就建立了完整的TCP连接,两边可以互相发送数据了

![[Pasted image 20240730152342.png]]

### 四次挥手

同样的,结束TCP连接有四次报文的传送

**第一步** 客户端要断开连接,会向服务器发送一个特殊的TCP报文,这个报文的`FIN`字段会被置成1,表示这是一个断开连接的请求报文

**第二步** 服务器接收到断开连接的报文,向客户端发送一个确实是否断开连接的报文,这个报文的ACK字段被置为1

**第三步** 服务器发送完确认报文之后会等待一段时间,然后自己再向客户端发送一个断开连接的报文,并将`FIN`置为1,然后将报文发送给客户端

**第四步** 客户端收到报文之后会产生一个确认报文,将ACK置为1后再发送给服务器,告知服务器接收到了断开连接的报文.服务器收到确认报文之后会释放这个TCP连接的相关资源(缓存和变量),而客户端会在两倍报文生存时间之后也清楚自己的数据,这段时间被称为`TIME_WAIT`

![[Pasted image 20240730153717.png]]

挥手的来回过程不局限于由客户端发起,服务器也可以发起断开请求

### `TIME_WAIT`为什么不能直接释放资源而要等一段时间再释放

不能保证最后一个ACK报文到达对方,如果长时间没有得到`FIN`的回应就会再发送一个`FIN`,这时候如果一方连接已经断开则会导致连接不一致的问题

保证连接两边的对应资源内存失效

### 为什么要四次挥手不是两次

因为TCP是全双工协议,两方都可以向对方传输数据,但是一方传输完数据向断开连接不代表另一方没有数据要传,所以需要双方都由断开连接的意向才可以断开连接

### 拥塞控制

TCP连接发送资源使用的是滑动窗口,但是为了防止在网络环境较差的情况下大量发送数据,导致网络环境更差,TCP引入了慢启动的机制

慢启动是TCP在发送数据时会先发送少量的数据以探测网络情况

---

