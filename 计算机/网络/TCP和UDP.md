tcp和udp都是传输层协议

**传输层：** 传输层是TCP/IP协议五层模型中的第四层。它提供了`应用程序`间的通信，它负责数据能够从发送端传输到接收端。其功能包括：**一、格式化信息流；二、提供可靠传输**。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。

# TCP

TCP全称`传输控制`协议，必须对数据的传输进行控制。

![[Pasted image 20240729164157.png]]

- 源端口号/目的端口号：表示数据从哪个`进程`来，要到那个进程去
- 32位序号：序号是`可靠传输`的关键因素。TCP将要传输的每个字节都进行了`编号`，序号是本报文段发送的数据组的`第一个`字节的编号，序号可以保证传输信息的有效性。**比如：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为401。**
- 32位确认序号：每一个`ACK`对应这一个确认号，它指明下一个期待收到的`字节`序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当`ACK`标志为1时才有效。**比如建立连接时，SYN报文的ACK标志位为0。**
- 4位首部长度(数据偏移)： 表示该TCP头部有多少个`32位bit`(有多少个4字节)，所以TCP头部大长度是`15 * 4 = 60`。根据该部分可以将TCP报头和有效载荷分离。TCP报文默认大小为20个字节。
- 6位标志位：
    **URG:它为了标志紧急指针是否有效。**  
    **ACK：标识确认号是否有效。**  
    **PSH:提示接收端应用程序立即将接收缓冲区的数据拿走。**  
    **RST：它是为了处理异常连接的， 告诉连接不一致的一方，我们的连接还没有建立好， 要求对方重新建立连接。我们把携带RST标识的称为复位报文段。**  
    **SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段。**  
    **FIN:通知对方, 本端要关闭连接了, 我们称携带FIN标识的为结束报文段。**
- 16位的`紧急`指针：按序到达是`TCP协议`保证可靠性的一种机制，但是也存在一些报文想优先被处理，这时就可以设置`紧急指针`，指向该报文即可，同时将紧急指针有效位置位`1`。
- 16位窗口大小：如果发送方发送`大量数据`，接收方接收不过来，会导致大量数据丢失。然后接收方可以发送给发送发消息让发送方发慢一点，这是`流量控制`。接收方将自己`接收缓冲器`剩余空间的大小告诉发送方叫做`16位窗口大小`。发送发可以根据窗口大小来`适配`发送的速度和大小，窗口大小最大是2的16次方，及64KB，但也可以根据选项中的某些位置扩展，最大扩展1G。
- 16位校验和：发送端填充，`CRC`校验。如果接收端校验不通过， 则认为数据有问题(此处的检验和不光包含`TCP首部`也包含`TCP数据部分`)。

## 确认应答机制

![[Pasted image 20240729172104.png]]

接收端收到一条报文后，向发送端发送一条`确认ACK`，此ACK的作用就是告诉发送端：接收端已经成功的收到了消息，并且希望收到下一条报文的`序列号`是什么。这个确认号就是期望的`下一个报文`的序号。

每一个ACK都带有对应的`确认序列号`，意思是告诉**发送者，我们已经收到了哪些数据，下一个发送数据应该从哪里开始**。 如上图，主机A给主机B发送了1-1000的数据，ACK应答，携带了1001序列号。告诉主机A，我已经接受到了1-1000数据，下一次你从1001开始发送数据。

## **超时重传:**

![[Pasted image 20240729172515.png]]

TCP在`传输数据`过程中，还加入了`超时重传`机制。假设主机A发送数据给主机B，主机B没有收到数据包，主机B自然就不会应答，如果主机A在一个特定时间间隔内没有收到主机B发来的确认应答，就会进行重发，这就是`超时重传机制`。  
当然还存在另一种可能就是`主机A`未收到`B`发来的确认应答，也可能是因为`ACK`丢失了。

![[Pasted image 20240729172558.png]]

因此主机B会收到很多`重复`数据，那么TCP协议需要能够识别出那些包是`重复的包`， 并且把重复的包丢弃掉，这时候我们可以利用前面提到的`16位序列号`， 就可以很容易做到`去重`的效果。

### **超时重发的时间应该如何确定？**  
在理想的情况下，可以找到一个`小的时间`来保证 "确认应答"一定能在这个时间内返回。但是这个时间的长短，随着`网络环境`的不同是有差异的。如果超时时间设的太长，会影响整体的`重传`效率。如果超时时间设的太短，有可能会`频繁发送重复`的包。`TCP`为了保证无论在任何环境下都能比较`高性能`的通信，因此会`动态计算`这个最大超时时间。

Linux中超时时间以`500ms`为一个单位进行控制，每次判定超时重发的`超时时间`都是`500ms`的整数倍。如果重发一次之后，仍然得不到应答，等待`2*500ms`后再进行重传。如果仍然得不到应答，等待`4*500ms`进行重传。依次类推，以`指数形式`递增，当累计到一定的重传次数，`TCP`认为网络或者对端主机出现`异常`，强制关闭连接。

## 连接管理机制

### 三次握手和四次挥手

在正常情况下, TCP要经过`三次握手`建立连接，`四次挥手`断开连接

第一步 有客户端想服务端发送一个tcp报文，这个报文不包含数据，且它的`SYN`字段被置为1,表示这是一个建立连接的请求,这个报文段也被称为SYN报文段,



# UDP

![[Pasted image 20240729162446.png]]

- 16位UDP长度表示整个数据报`(UDP首部+UDP数据)`的长度
- 如果校验和出错，就会直接丢弃(UDP校验首部和数据部分)

udp特点

- 无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。
- 不可靠：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。
- 面向数据报： 应用层交给`UDP`多长的报文， UDP原样发送既不会拆分，也不会合并。

**UDP的缓冲区：UDP存在接收缓冲区**

- UDP没有发送缓冲区，在调用`sendto`时会直接将数据交给内核，由内核将数据传给`网络层协议`进行后续的传输动作。
- UDP具有接收缓冲区，但是这个`接收缓冲区`不能保证收到的UDP报文的顺序和发送UDP报的顺序一致，如果缓冲区满了再到达的UDP数据报就会被丢弃。

**UDP是一种`全双工`通信协议。 UDP协议首部中有一个16位的大长度. 也就是说一个UDP能传输的报文长度是`64K`(包含UDP首部)。如果我们需要传输的数据超过64K, 就需要在应用层手动的`分包`, 多次发送, 并在接收端手动拼装。**